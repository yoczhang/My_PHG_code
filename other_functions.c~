/* The functions in this file are written by myself, aiming to 
 * solve the transport-equations */

/* $Id: other_functions.c, v 0.1 2015/09/04 10:11:00 zlb Exp $ */
#include "phg.h"
#include "phg/quad-gauss.h"
#include "phg/quad-permu.h"
#include "other_functions.h"
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>

/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/
/* beta_function.c */
FLOAT
beta_function(INT l, INT m, INT c){
    FLOAT r;
    r=c*sqrt(((FLOAT)l-m)*(l-m-1)/(4*(2*l-1)*(2*l+1)));
    return r;
}//endof-beta_function


/* alpha_function.c */
FLOAT
alpha_function(INT l, INT m, INT c){
    FLOAT r;
    r=c*sqrt(((FLOAT)l+m+2)*(l+m+1)/(4*(2*l+1)*(2*l+3)));
    return r;
}//endof-alpha_function


/* gamma_function.c */
FLOAT
gamma_function(INT l, INT m, INT c){
    FLOAT r;
    r=c*sqrt(((FLOAT)l-m)*(l+m)/((2*l-1)*(2*l+1)));
    return r;
}//endof-gamma_function


/* eta_function.c */
FLOAT
eta_function(INT l, INT m, INT c){
    FLOAT r;
    r=c*sqrt(((FLOAT)l+m+1)*(l-m+1)/((2*l+3)*(2*l+1)));
    return r;
}//endof-eta_function
/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/



/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/
/* build_D_x_matrix.c */
void
build_D_x_matrix(INT N, FLOAT **D_x)
{
    /* it is easy to compute that in P_N(0,1,...N) approximate the number 
     * of how many Y_l^m is (N+1)*(N+1), so the D_x is a n*n matrix */
    /*
    INT n;
    n=(N+1)*(N+1);
    INT i,j;
    for(i=0;i<n;i++)
        *(D_x+i)=(FLOAT *)malloc(n*sizeof(FLOAT));
    for(i=0;i<n;i++){
        for(j=0;j<n;j++)
            *(*(D_x+i)+j)=0.0;
    }
    // Just only to give an initial value to matrix D_x 
    */

    INT l,m;
    INT row,col;//ptr;//ptr is to transform row and col to 1 dim in row storage
    for(l=0;l<=N;l++){
        for(m=-l;m<=l;m++){
            if(l-1>=0){
                if(m-1>=-(l-1)){
                    col=l*l+l+m;
                    row=(l-1)*(l-1)+(l-1)+(m-1);
                    //ptr=row*n+col;
                    *(*(D_x+row)+col)=beta_function(l,-m,-1);
                }//endof-if(m-1)
                if(m+1<=l-1){
                    col=l*l+l+m;
                    row=(l-1)*(l-1)+(l-1)+(m+1);
                    //ptr=row*n+col;
                    *(*(D_x+row)+col)=beta_function(l,m,1);
                }//endof-if(m+1)
            }//endof-if(l-1)

            if(l+1<=N){
                if(m-1>=-(l+1)){
                    col=l*l+l+m;
                    row=(l+1)*(l+1)+(l+1)+(m-1);
                    //ptr=row*n+col;
                    *(*(D_x+row)+col)=alpha_function(l,-m,1);
                }//endof-if(m-1)
                if(m+1<=l+1){
                    col=l*l+l+m;
                    row=(l+1)*(l+1)+(l+1)+(m+1);
                    //ptr=row*n+col;
                    *(*(D_x+row)+col)=alpha_function(l,m,-1);
                }//endof-if(m+1)
            }//endof-if(l+1)
        }//endof-for(m=-l;...)
    }//endof-for(l=0;...)
}//endof-build_D_matrix


/* build_D_y_matrix.c */
void
build_D_y_matrix(INT N, FLOAT **D_y)
{
    /* it is easy to compute that in P_N approximate the number 
     * of how many Y_l^m is (N+1)*(N+1), so the D_x is a n*n matrix */
    /*
    INT n;
    n=(N+1)*(N+1);
    INT i,j;
    for(i=0;i<n;i++)
        *(D_y+i)=(FLOAT*)malloc(n*sizeof(FLOAT));
    for(i=0;i<n;i++){
        for(j=0;j<n;j++)
            *(*(D_y+i)+j)=0.0;
    }
    // Just only to give an initial value to matrix D_x 
    */
    
    INT l,m;
    INT row,col;//ptr;//ptr is to transform row and col to 1 dim in row storage
    for(l=0;l<=N;l++){
        for(m=-l;m<=l;m++){
            if(l-1>=0){
                if(m-1>=-(l-1)){
                    col=l*l+l+m;
                    row=(l-1)*(l-1)+(l-1)+(m-1);
                    //ptr=row*n+col;
                    *(*(D_y+row)+col)=beta_function(l,-m,1);
                }//endof-if(m-1)
                if(m+1<=l-1){
                    col=l*l+l+m;
                    row=(l-1)*(l-1)+(l-1)+(m+1);
                    //ptr=row*n+col;
                    *(*(D_y+row)+col)=beta_function(l,m,-1);
                }//endof-if(m+1)
            }//endof-if(l-1)

            if(l+1<=N){
                if(m-1>=-(l+1)){
                    col=l*l+l+m;
                    row=(l+1)*(l+1)+(l+1)+(m-1);
                    //ptr=row*n+col;
                    *(*(D_y+row)+col)=alpha_function(l,-m,-1);
                }//endof-if(m-1)
                if(m+1<=l+1){
                    col=l*l+l+m;
                    row=(l+1)*(l+1)+(l+1)+(m+1);
                    //ptr=row*n+col;
                    *(*(D_y+row)+col)=alpha_function(l,m,1);
                }//endof-if(m+1)
            }//endof-if(l+1)
        }//endof-for(m=-l;...)
    }//endof-for(l=0;...)
}//endof-build_D_matrix


/* build_D_z_matrix.c */
void
build_D_z_matrix(INT N, FLOAT **D_z){
    /*
    INT n=(N+1)*(N+1);
    INT i;
    for(i=0;i<n;i++)
        *(D_z+i)=(FLOAT *)malloc(n*sizeof(FLOAT));
    
    printf("testing build_D_z_matrix1\n");
    for(i=0;i<n;i++){
        for(j=0;j<n;j++)
	    printf("i=%d, j=%d \n",i,j);
            *(*(D_z+i)+j)=0.0;
    }
    printf("testing build_D_z_matrix\n");
    */
    INT l,m;
    INT col,row;//ptr;
    for(l=0;l<=N;l++){
        for(m=-l;m<=l;m++){
            if(l-1>=0 && m!=-l && m!=l){
                col=l*l+l+m;
                row=(l-1)*(l-1)+(l-1)+m;
                //printf("left1: l=%d, m=%d, row=%d, col=%d \n",l,m,row,col);
                //ptr=row*n+col;
                *(*(D_z+row)+col)=gamma_function(l,m,1);
                //printf("left2: l=%d, m=%d, row=%d, col=%d, D_Z[%d][%d]=%f \n",l,m,row,col,row,col,*(*(D_z+row)+col));
            }
            if(l+1<=N){
                col=l*l+l+m;
                row=(l+1)*(l+1)+(l+1)+m;
                //printf("right1: l=%d, m=%d, row=%d, col=%d \n",l,m,row,col);
                //ptr=row*n+col;
                *(*(D_z+row)+col)=eta_function(l,m,1);
                //printf("right2: l=%d,m=%d, row=%d, col=%d, D_Z[%d][%d]=%f \n",l,m,row,col,row,col,*(*(D_z+row)+col));
            }
        }//endof-for(m=-l)
    }//endof-for(l=0)
}//endof-build_D_z_matrix
/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/



/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/
/*
 * Next considering the matrix A(or A^T) multiply matrix B
 * here, we just take the consideration that A and B are same 
 * order: A(n*n) B(n*n)
 * */
void
MatA_multiply_MatB(BOOLEAN tran, INT n, FLOAT **A, FLOAT **B, FLOAT **C){
    /*
     * the BOOLEAN is defined in phg.h, the values are TRUE(1) and FLASE(0),
     * when tran=TRUE stands for C= A^T * B, tran=FALSE stands for C= A * B.
     * And more, here we just consider A and B are the same size, so the code
     * is the simplest.
     * if C= A * B, then C_{ij}=\sum_k A_{ik}*B_{kj}.
     * if C= A^T *B, then C_{ij}=\sum_k A_{ki}*B_{kj}.
     * */
    INT i,j,k;
    FLOAT val=0.0;
    if(tran==TRUE){
        for(i=0;i<n;i++){
            for(j=0;j<n;j++){
                val=0.0;
                for(k=0;k<n;k++)
                    val=val+A[k][i]*B[k][j];
                *(*(C+i)+j)=val;
            }//endof-for(j=0;...)
        }//endof-for(i=0;...)
    }//endof-if(tran==TRUE)
    
    if(tran==FALSE){
        for(i=0;i<n;i++){
            for(j=0;j<n;j++){
                val=0.0;
                for(k=0;k<n;k++)
                    val=val+A[i][k]*B[k][j];
                *(*(C+i)+j)=val;
            }//endof-for(j=0;...)
        }//endof-for(i=0;...)
    }//endof-if(tran==FALSE)

}//endof-MatA_multiply_MatB
/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/



/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/
/*
 * This code is to compute C=A*M*B, or C=A^T * M * B
 * first using the function MatA_multiply_MatB(), compute tmp = A^T*M, 
 * then also using function MatA_multiply_MatB(), compute C = tmp*B,
 *
 */
void
Compute_D_xx_x(BOOLEAN tran1, BOOLEAN tran2, INT n, FLOAT ** A, FLOAT ** M, 
        FLOAT **B, FLOAT **C)
{
    INT i;
    FLOAT **tmp;
    tmp=(FLOAT **)malloc(sizeof(FLOAT *)*n);
    for(i=0;i<n;i++){
        *(tmp+i)=(FLOAT *)malloc(n*sizeof(FLOAT));
    }
    
    MatA_multiply_MatB(tran1, n, A, M, tmp);
    MatA_multiply_MatB(tran2, n, tmp, B, C);

}//endof_Compute_D_xx_x

/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/



/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/
void
test_2_dim_pointer(int n, double **A){
    int i;
    int j;
    for(i=0;i<n;i++)
        *(A+i)=(double*)malloc(n*sizeof(double));
    
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            A[i][j]=i+j*1.0;

    printf("entering test_2_dim_pointer\n");
    for(i=0;i<n;i++){
        for(j=0;j<n;j++){
            printf("i=%d, j=%d",i,j);
            printf("A[%d][%d]=%f  ",i,j,A[i][j]);
        }
    }


}
/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/



/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/
/*
 * The following funcion is to compute the integration of the...
 *
 * 下面的函数是在单元e上计算第m，n个基函数的偏导数乘积的积分，
 * 其中ParGradi(ParGradj)取0时表示对x的偏导数，1表示对y的偏导数，
 * 2表示对z的偏导数。
 *
 * 此函数是在 quad.c 中 phgQuadGradBasAGradBas 函数的基础上改的，
 * 并且只用到了A=NULL 的情况，所以A！=NULL 的都删掉了。
 */
FLOAT
phgQuadBasParGradi_BasParGradj(ELEMENT *e, int ParGradi, DOF *u, int n, 
        int ParGradj, DOF *v, int m, int order)
{
    int i, j, nvalues = DofTypeDim(u);
    FLOAT d, d0;
    const FLOAT *g1, *g2, *w;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
    assert(nvalues == DofTypeDim(v));

    if (order < 0) {
	    order = BasisOrder(u, e, n) - 1 + BasisOrder(v, e, m) - 1;
	    if (order < 0)
	        order = 0;
    }
    quad = phgQuadGetQuad3D(order);

    d = 0.;
    g1 = phgQuadGetBasisGradient(e, u, n, quad);
    g2 = phgQuadGetBasisGradient(e, v, m, quad);
    w = quad->weights;
    
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		    d0 += *(g1+ParGradi) * *(g2+ParGradj);
		    g1 += Dim;
		    g2 += Dim;
	    }
	    d += d0 * (*(w++));
	}
	return d * phgGeomGetVolume(u->g, e);
    
}
/*--------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/


